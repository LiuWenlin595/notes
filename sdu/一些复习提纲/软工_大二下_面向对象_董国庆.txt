抽象    1团体	2单元	3CS
信息隐藏

抽象形式	1分治法		2特化分层	3不同视角	4分类	5组合	6模式
继承方式	1has-a(组合，持有对方引用)		2is-a
抽象数据类型思想	把接口和实现的概念分离开来

汇编语言和过程	以功能为中心
模块和ADT	以数据为中心
面向对象	以服务为中心

对象：对象标识	复合对象	委托	组合/聚合	对象持久化
类：	类是对象的抽象，对象是类的实例

元类	泛化/特化	浅拷贝/深拷贝
特殊化继承，规范化继承
构造继承，泛化继承，扩展继承，限制继承，变体继承，合并继承

接口相较于抽象类的优点：
1一个类可以实现多个接口		2设计和实现完全分离		3更自然的使用多态
4更容易搭建程序框架		5更容易更换实现



UML 
+size:Area[2...n ordered]=(100,100)
关联关系：自反关联	二元关联	N元关联  -------->
聚合关系：共享聚合	组合(同生死)    ---------------<> 黑白
泛化关系：继承  ----------|>
依赖关系：- - - ->
实现：- - - -|>
派生属性和派生关联



设计模式
工厂模式：简单工厂，工厂方法工厂，抽象工厂
单例模式：饿汉式，懒汉式
适配器模式：类适配，对象适配
装饰者模式：就那样
代理模式：一个类的功能让另一个类来完成
桥梁模式：一方面定义主类，另一方面作为特征关联到主类
观察者模式：让被观察者持有观察者的引用
策略模式：搞一个策略基类，底下区分为不同的策略
责任链模式：每个负责人持有一个更高负责人的引用，避免了ifelse




设计原则
开-闭原则：软件组成实体应该是可扩展的，但是不可修改的 //通过定义一层完整的抽象类来实现
如何修改不符合的设计：将变化点抽象出一层，结合具体设计模式，进行改进

里氏替换原则：使用指向基类的引用的函数，必须能够在不知道具体派生类对象类型的情况下使用它们
如何修改不符合的设计：在"子类"中声明一个"父类"的对象，委托"父类"来完成相应的操作

依赖倒转原则：抽象不应该依赖于细节，细节应当依赖于抽象

组合复用原则：优先使用组合，而非继承

迪米特法则(最小知识法则)：一个对象应该对其他对象尽可能少的了解

接口隔离原则：一个类对另一个类的依赖应当建立在最小的接口上

单一职责原则：不要存在多于一个导致类变更的原因








多态：不同的对象收到相同的消息时，会产生不同行为

多态的三种形式？1重载	2改写	3多态变量	4泛型

为什么需要泛型？我们希望容器能够同时持有多种类型对象，但是通常容器只会存储一种。泛型的目的之一就是指定容器要持有什么类型的对象，
并由编译器保证类型的正确性。与其使用object，更好的选择是暂时不指定类型，在使用的时候再指定。

反射和自省：程序在运行过程中了解自身的能力

可替换性：变量声明时指定的类型不必与他所容纳的值的类型相一致

静态类：用于声明变量的类
动态类：与变量所表示的当前数值相关的类

反多态：做出数值是否属于指定类的决定之后，通常下一步就是将这一数值的类型由父类转换为子类

响应消息时对哪个方法进行绑定是由接收器当前所包含的动态数值决定的

多态变量：可以引用多种数据类型的变量
方法所执行的消息绑定是由最近赋值给变量的数据的类型决定的

多重继承的实现：1实现多个接口	2构造内部类

强制(隐式)，转换(显式)和造型

重定义：当子类定义了一个与父类具有相同名称但类型参数不同的方式时，发生重定义

重定义和改写的区别：重定义的类型签名发生了变化，改写的函数签名不变

延时方法：如果这方法在父类中定义，但是并没有实现，则该方法叫做延时方法

遮蔽(在父类中不声明为虚拟的)：在编译时基于静态类型解析的，并且不需要运行时机制

协方差：将一个类型降低类型层次变成子类
反协方差：将一个类型提高类型层次变成父类
非方差：子类不允许以任何方式改变关于改写方法的类型签名

接收器变量：类似于this

纯多态：(多态方法)支持可变参数，通常通过给方法的接收器发送延时消息来实现，参数类型为多态变量

框架：对于一类相似问题的骨架解决方案

对象互联：两个对象的依赖关系
耦合描述类之间的关系，内聚描述类内部的关系

耦合的类型(差->好)：
内部数据耦合：一个类的实例直接修改另一个类的本地数据值
全局数据耦合：两个或更多的类都依赖于全局的公用数据结构而绑定到一起
控制(顺序)耦合：一个类必须以一种特定的顺序来执行操作
组件耦合：一个类包含的数据字段为另一个类的实例
参数耦合：一个类需要调用另一个类的服务和例程，两个类之间发生的唯一关系就是一个类需要为另一个类提供参数数目、类型和返回值
子类耦合：继承

内聚的类型(弱->强)：	
随机内聚：对程序任意划分
逻辑内聚：算术函数库
时间内聚：实现函数初始化的类
通信内聚：数据或者设备的manager
顺序内聚：避免顺序耦合
功能内聚：类中元素通过执行特定功能关联起来
数据内聚：数据结构

参数化类：尚未完全说明的类，需要用户提供参数(泛型)

对象图：和类图相似，(对象名：类名)，对象的名字下面要加下划线

const和final：
const是常量，不允许改变
final仅说相关变量不会赋予新值，并不能阻止在对象内部对变量值进行改变

联编：把一个过程调用和响应这个调用而需要将执行的代码加以结合的过程

引入元类的优点：
概念上一致
使类成为运行时刻一部分有助于改善程序设计环境
继承的规范化，类与元类的继承采用双轨制

反射内省：
if (a instanceof (balabala)) {
	(balabala)a.opeartionbalabala();
} else if(a instance of (balabala2)) {
	(balabala2)a.operationbalabala2();}

内存分配

2015
1.叙述元类的作用，并举例说明。
2.举例说明伪变量this的多态性。
3.简述替换原则，说明C++和Java分别采用了何种内存分配策略，来支持替换原则.  
4.简述重载、 重定义、改写之间的关系。
5.比较组合复用和继承复用的优缺点，如何决定使用哪种复用方式？
6.什么是纯多态？举例说明其作用。


1.试用面向对象语言简述改写和重定义的异同，以及方法绑定时的差别 
2.试用面向对象语言简述this的多态性 
3.试用面向对象语言简述替换原则 
4.为什么要尽量使用组合复用而不要用继承复用 
5.重载方法绑定书P91页例子，简述重载方法绑定的步骤 


多态四种类型
代码复用
继承的八种


如何实现代码复用：1持有对方引用	2在方法中调用	3继承

